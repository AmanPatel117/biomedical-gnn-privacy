import torch
import numpy as np
from torch.nn import functional as F
from torch_geometric import transforms as T

from ml_util import get_accuracy


def query_zero_hop(model, v_feat):
    '''
    Perform a zero-hop query on a trained model. The only input is the node and its features, with a self loop
    to itself.
    
    v_feat should be a 1D vector.
    '''
    edge_index = torch.tensor([[0], [0]], dtype=int).to(DEVICE)
    return model(v_feat.unsqueeze(0).to(DEVICE), edge_index)


def zero_hop_acc(model, data, mask):
    '''Get the accuracy of the model by only inputting 0-hop graphs; i.e. only the features of the node of interest and nothing else'''
    model.eval()
    with torch.no_grad():
        pred = torch.stack([query_zero_hop(model, v_feat).cpu().flatten() for v_feat in data.x[mask]])
        y = data.y[mask].cpu()
        return get_accuracy(pred, y)
    
    
def split_in_half(data):
    '''Split a Data object in half. Severs edges between the two halves and preserves edges within each half'''
    half_split_transform = T.RandomNodeSplit(split='train_rest', num_val=0.5, num_test=0.)
    return half_split_transform(data)
    

def ind_to_mask(ind, size):
    '''Takes a list of indices and returns a boolean mask which is True at every spot specified by the indices'''
    return np.isin(np.arange(size), ind)
    
    
def target_shadow_split(data):
    '''
    Split data randomly and equally into two objects, one for target model training and one for shadow model training. Each 
    Data object is also further split by half, as their train and test sets.
    '''
    n_nodes = data.x.shape[0]
    data_halved = split_in_half(data)
    t_ind, s_ind = torch.where(data_halved.train_mask)[0], torch.where(~data_halved.train_mask)[0]
    
    # Shuffle target indices; then assign first half as train and second half as test
    t_ind_shuffle = np.random.choice(t_ind, size=len(t_ind), replace=False)
    t_ind_train, t_ind_test = np.sort(t_ind_shuffle[:len(t_ind)//2]), np.sort(t_ind_shuffle[len(t_ind)//2:])
    
    # Shuffle shadow indices; then assign first half as train and second half as test
    s_ind_shuffle = np.random.choice(s_ind, size=len(s_ind), replace=False)
    s_ind_train, s_ind_test = np.sort(s_ind_shuffle[:len(s_ind)//2]), np.sort(s_ind_shuffle[len(s_ind)//2:])
    
    # Assign masks to Data objects
    t_data = data.clone()
    t_data.train_mask = ind_to_mask(t_ind_train, n_nodes)
    t_data.test_mask = ind_to_mask(t_ind_test, n_nodes)
    t_data.val_mask = t_data.test_mask
    
    s_data = data.clone()
    s_data.train_mask = ind_to_mask(s_ind_train, n_nodes)
    s_data.test_mask = ind_to_mask(s_ind_test, n_nodes)
    s_data.val_mask = s_data.test_mask
    
    return t_data, s_data


def create_attack_dataset(model, data):
    '''
    Creates the attack dataset using 0-hop querying on a trained shadow model. Each data pair consists is generated from a node feature v. The x variable is the posterior
    generated by the shadow model for input v, and the label is binary- True if v is in the shadow model's train dataset, and False if it was in the test/val dataset.
    
    s_model (nn.Module): GNN trained on the shadow dataset
    s_data (torch_geometric.data.Data): Data object representing a graph, with appropriate train_mask and test_mask defined.
    '''
    
    feat = data.x[data.train_mask | data.test_mask]    
    posteriors = F.sigmoid(torch.vstack([query_zero_hop(model, v_feat).sort()[0] for v_feat in feat]).detach().cpu(), dim=1)
    membership = torch.tensor(np.array([data.train_mask[i] for i in range(data.num_nodes) if (data.train_mask[i] or data.test_mask[i])]), dtype=torch.int)
    membership = torch.Tensor(OneHotEncoder().fit_transform(membership.reshape(-1,1)).todense())
    return posteriors, membership
    